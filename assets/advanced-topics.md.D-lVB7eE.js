import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.DWxUEc8X.js";const c=JSON.parse('{"title":"Advanced Topics","description":"","frontmatter":{},"headers":[],"relativePath":"advanced-topics.md","filePath":"advanced-topics.md"}'),n={name:"advanced-topics.md"};function l(p,s,r,h,o,d){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="advanced-topics" tabindex="-1">Advanced Topics <a class="header-anchor" href="#advanced-topics" aria-label="Permalink to &quot;Advanced Topics&quot;">​</a></h1><p>This page covers advanced usage patterns, performance tips, and integration patterns for Ripple Router.</p><h2 id="nested-routing-patterns" tabindex="-1">Nested routing patterns <a class="header-anchor" href="#nested-routing-patterns" aria-label="Permalink to &quot;Nested routing patterns&quot;">​</a></h2><p>Ripple Router supports nesting by simply placing <code>Route</code> components inside other components. The router resolves the best matching route by walking the tree.</p><p>Example: nested dashboard with side nav</p><div class="language-JSX vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JSX</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Router</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dashboard&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{Dashboard} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;settings&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{Settings} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Router</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>When structuring nested routes, prefer small components and delegate parameter parsing to child route elements for clarity.</p><h2 id="route-based-code-splitting" tabindex="-1">Route-based code-splitting <a class="header-anchor" href="#route-based-code-splitting" aria-label="Permalink to &quot;Route-based code-splitting&quot;">​</a></h2><p>To reduce initial bundle size, load route elements lazily using dynamic imports and a small loader component.</p><div class="language-JSX vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JSX</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LazyProfile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./Profile.ripple&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/profile&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{LazyProfile} /&gt;</span></span></code></pre></div><p>Ensure your bundler handles asynchronous components properly (most modern bundlers do).</p><h2 id="performance-considerations" tabindex="-1">Performance considerations <a class="header-anchor" href="#performance-considerations" aria-label="Permalink to &quot;Performance considerations&quot;">​</a></h2><ul><li>Keep path matching patterns simple and avoid overly permissive wildcards.</li><li>Cache expensive operations (e.g., complex matchers) when used repeatedly.</li><li>Minimize re-renders by keeping route element props stable; avoid creating new inline objects in parent renders.</li></ul><h2 id="accessibility" tabindex="-1">Accessibility <a class="header-anchor" href="#accessibility" aria-label="Permalink to &quot;Accessibility&quot;">​</a></h2><ul><li>Ensure <code>&lt;Link&gt;</code> components render semantic anchor tags with <code>href</code> so screen readers and keyboard users get expected behavior.</li><li>Provide skip links for keyboard users when you have route changes that move focus.</li></ul><h2 id="tips-for-large-apps" tabindex="-1">Tips for large apps <a class="header-anchor" href="#tips-for-large-apps" aria-label="Permalink to &quot;Tips for large apps&quot;">​</a></h2><ul><li>Centralize route definitions in a single module for discoverability.</li><li>Use a route meta system (simple JS object attached to routes) to store permissions, titles and breadcrumbs instead of duplicating logic across components.</li></ul>`,17)])])}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
